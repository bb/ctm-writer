/*
 * Copyright: Copyright 2010 Topic Maps Lab, University of Leipzig. http://www.topicmapslab.de/    
 * License:   Apache License, Version 2.0 http://www.apache.org/licenses/LICENSE-2.0.html
 * 
 * @author Sven Krosse
 * @email krosse@informatik.uni-leipzig.de
 *
 */
package de.topicmapslab.ctm.writer.core.serializer;

import static de.topicmapslab.ctm.writer.utility.CTMTokens.UTF8ENCODING;
import static de.topicmapslab.ctm.writer.utility.CTMTokens.VERSION;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import org.tmapi.core.Association;
import org.tmapi.core.Construct;
import org.tmapi.core.Name;
import org.tmapi.core.Occurrence;
import org.tmapi.core.Role;
import org.tmapi.core.Topic;
import org.tmapi.core.TopicMap;
import org.tmapi.core.Variant;

import de.topicmapslab.ctm.writer.core.PrefixHandler;
import de.topicmapslab.ctm.writer.exception.NoIdentityException;
import de.topicmapslab.ctm.writer.exception.SerializerException;
import de.topicmapslab.ctm.writer.properties.CTMTopicMapWriterProperties;
import de.topicmapslab.ctm.writer.templates.Template;
import de.topicmapslab.ctm.writer.templates.TemplateMerger;
import de.topicmapslab.ctm.writer.templates.TemplateSerializer;
import de.topicmapslab.ctm.writer.templates.autodetection.TemplateDetection;
import de.topicmapslab.ctm.writer.templates.entry.AssociationEntry;
import de.topicmapslab.ctm.writer.utility.CTMBuffer;
import de.topicmapslab.ctm.writer.utility.CTMIdentity;
import de.topicmapslab.ctm.writer.utility.TMDMIdentifier;

/**
 * Class to realize the serialization of the following CTM grammar rule. <br />
 * <br />
 * <code>	topicmap ::=	prolog
 * 							( directive* reifier )?
 * 							(
 * 	 							directive	  |
 * 								topic	  |
 * 								association	  |
 * 								template	  |
 * 								template-invocation	
 * 							)   </code><br />
 * <br />
 * The serialized CTM string represents the a topic map block.
 * 
 * @author Sven Krosse
 * @email krosse@informatik.uni-leipzig.de
 * 
 */
public class TopicMapSerializer implements ISerializer<TopicMap> {

	/**
	 * set of defined templates
	 */
	private final Set<Template> templates = new HashSet<Template>();
	/**
	 * properties for CTM topic map writer
	 */
	private final CTMTopicMapWriterProperties properties;

	/**
	 * identity utility (cache and generator)
	 */
	private final CTMIdentity ctmIdentity;

	/**
	 * the prefix handler
	 */
	private final PrefixHandler prefixHandler;

	public TopicMapSerializer(CTMTopicMapWriterProperties properties,
			PrefixHandler prefixHandler) {
		this.properties = properties;
		this.prefixHandler = prefixHandler;
		this.ctmIdentity = new CTMIdentity(prefixHandler);		
	}

	/**
	 * add a template to the internal set. Templates are used to replace
	 * frequently used parts of topic blocks or associations.
	 * 
	 * @param template
	 *            the template to add
	 */
	public void add(Template template) {
		templates.add(template);
	}

	/**
	 * {@inheritDoc}
	 */
	public boolean serialize(TopicMap topicMap, CTMBuffer buffer)
			throws SerializerException {

		/*
		 * add comment
		 */
		buffer.appendCommentLine("Generated by the CTM Topic Map Writer.");

		/*
		 * add encoding
		 */
		buffer.appendLine(UTF8ENCODING);

		/*
		 * add version
		 */
		buffer.appendLine(VERSION);

		/*
		 * add reification of topic map if exists
		 */
		CTMBuffer ctmBuffer = new CTMBuffer();
		if (new ReifiableSerializer(properties, ctmIdentity).serialize(
				topicMap, ctmBuffer)) {
			buffer.appendCommentLine("reifier of the topicmap");
			buffer.appendLine(ctmBuffer);
			buffer.appendLine();
		}

		/*
		 * add prefixes if auto-detection is enabled
		 */
		CTMBuffer prefixBuffer = new CTMBuffer();
		if (properties.isPrefixDetectionEnabled()) {
			buffer.appendCommentLine("prefixes");
			buffer.appendLine();
			if (new PrefixesSerializer(prefixHandler).serialize(topicMap,
					prefixBuffer)) {
				buffer.appendLine(prefixBuffer);
			}
			buffer.appendLine();
		}

		/*
		 * start topic map block
		 */
		buffer.appendLine();

		/*
		 * try to auto-detect templates if properties is enabled
		 */
		if (properties.isTemplateDetectionEnabled()) {
			TemplateDetection detection = new TemplateDetection(properties,
					ctmIdentity, topicMap);
			templates.addAll(detection.tryToDetectTemplates());
		}

		/*
		 * try to merge templates if properties is set
		 */
		if (properties.isTemplateMergerEnabled()) {
			Collection<Template> templates = new TemplateMerger(properties)
					.mergeTemplates(this.templates);
			this.templates.clear();
			this.templates.addAll(templates);
		}

		/*
		 * generate template-definition blocks
		 */
		if (!templates.isEmpty()) {
			buffer.appendCommentLine("template definitions");
		}
		for (Template template : templates) {
			ctmBuffer = new CTMBuffer();
			new TemplateSerializer(template).serialize(ctmBuffer);
			buffer.appendLine(ctmBuffer);
		}

		/*
		 * generate topic-definition blocks
		 */
		buffer.appendCommentLine("topic definitions");
		for (Topic topic : topicMap.getTopics()) {
			/*
			 * ignore TMDM topics
			 */
			if (!topic.getSubjectIdentifiers().isEmpty()
					&& TMDMIdentifier.TMDM_IDENTIFIERS.contains(topic
							.getSubjectIdentifiers().iterator().next()
							.toExternalForm())) {
				continue;
			}
			serializeTopicToCTM(topic, buffer);
		}

		/*
		 * generate association-definition blocks
		 */
		buffer.appendCommentLine("association definitions");
		for (Association association : topicMap.getAssociations()) {
			ctmBuffer = new CTMBuffer();
			try {
				ctmIdentity.getIdentity(properties, association.getType());
				/*
				 * ignore TMDM associations
				 */
				if (!association.getType().getSubjectIdentifiers().isEmpty()
						&& TMDMIdentifier.TMDM_IDENTIFIERS.contains(association
								.getType().getSubjectIdentifiers().iterator()
								.next().toExternalForm())) {
					continue;
				}
				new AssociationSerializer(properties, ctmIdentity,
						getAdaptiveTemplates(association)).serialize(
						association, ctmBuffer);
				buffer.appendLine(ctmBuffer);
			} catch (NoIdentityException e) {
			}
		}

		/*
		 * end topic map definition
		 */
		return true;
	}
	
	/**
	 * Method to convert the given constructs to its specific CTM strings. The
	 * result should be written to the given output buffer.
	 * 
	 * @param constructs
	 *            a set of topic map constructs to serialize
	 * @param buffer
	 *            the output buffer
	 * @return <code>true</code> if new content was written into buffer,
	 *         <code>false</code> otherwise
	 * @throws SerializerException
	 *             Thrown if serialization failed.
	 */
	public boolean serialize(Collection<Construct> constructs, CTMBuffer buffer)
			throws SerializerException {

		/*
		 * topic item store 
		 */
		Collection<Topic> topics = new HashSet<Topic>();
		/*
		 * association item store
		 */
		Collection<Association> associations = new HashSet<Association>();
		
		/*
		 * sort constructs by type
		 */
		for ( Construct construct : constructs ){
			if ( construct instanceof Topic){
				topics.add((Topic)construct);
			}else if ( construct instanceof Name){
				topics.add(((Name)construct).getParent());
			}else if ( construct instanceof Occurrence){
				topics.add(((Occurrence)construct).getParent());
			}else if ( construct instanceof Variant){
				topics.add(((Variant)construct).getParent().getParent());
			}else if ( construct instanceof Association){
				associations.add(((Association)construct));
			}else if ( construct instanceof Role){
				associations.add(((Role)construct).getParent());
			}
		}
		
		/*
		 * add comment
		 */
		buffer.appendCommentLine("Generated by the CTM Topic Map Writer.");

		/*
		 * add encoding
		 */
		buffer.appendLine(UTF8ENCODING);

		/*
		 * add version
		 */
		buffer.appendLine(VERSION);

		/*
		 * start topic map block
		 */
		buffer.appendLine();


		/*
		 * generate topic-definition blocks
		 */
		buffer.appendCommentLine("topic definitions");
		for (Topic topic : topics) {			
			serializeTopicToCTM(topic, buffer);
		}

		/*
		 * generate association-definition blocks
		 */
		buffer.appendCommentLine("association definitions");		
		for (Association association : associations) {
			CTMBuffer ctmBuffer = new CTMBuffer();
			try {
				ctmIdentity.getIdentity(properties, association.getType());
				/*
				 * ignore TMDM associations
				 */
				new AssociationSerializer(properties, ctmIdentity,
						getAdaptiveTemplates(association)).serialize(
						association, ctmBuffer);
				buffer.appendLine(ctmBuffer);
			} catch (NoIdentityException e) {
			}
		}

		/*
		 * end topic map definition
		 */
		return true;
	}

	/**
	 * Internal method to export the given topic to CTM if topic is not a TMDM
	 * type. The result is written to the given buffer.
	 * 
	 * @param topic
	 *            the topic to export
	 * @param buffer
	 *            the buffer written to
	 * @return <code>true</code> if new content was written to the given buffer,
	 *         <code>false</code> otherwise.
	 * @throws SerializerException
	 *             thrown if serialization failed
	 */
	private final boolean serializeTopicToCTM(final Topic topic,
			final CTMBuffer buffer) throws SerializerException {
		CTMBuffer ctmBuffer = new CTMBuffer();
		try {
			/*
			 * generate only for non TMDM types
			 */
			ctmIdentity.getIdentity(properties, topic);
			new TopicSerializer(properties, getAdaptiveTemplates(topic),
					ctmIdentity).serialize(topic, ctmBuffer);
			buffer.appendLine(ctmBuffer);
			return true;
		} catch (NoIdentityException e) {
			return false;
		}
	}

	/**
	 * Extract adaptive templates from internal list.
	 * 
	 * @param topic
	 *            the topic which should be adaptive to the templates
	 * @return a set of adaptive templates for the given topic
	 */
	private final Set<Template> getAdaptiveTemplates(final Topic topic) {
		Set<Template> templates = new HashSet<Template>();

		for (Template t : this.templates) {
			if (!t.containsOnlyInstanceOf(AssociationEntry.class)
					&& !t.getTemplateName().matches(".*-invoc--?[0-9]+")
					&& t.isAdaptiveFor(topic)) {
				templates.add(t);
			}
		}
		return templates;
	}

	/**
	 * Extract adaptive templates from internal list.
	 * 
	 * @param association
	 *            the association which should be adaptive to the templates
	 * @return a set of adaptive templates for the given association
	 */
	private final Set<Template> getAdaptiveTemplates(
			final Association association) {
		Set<Template> templates = new HashSet<Template>();

		for (Template t : this.templates) {
			if (t.containsOnlyInstanceOf(AssociationEntry.class)
					&& t.isAdaptiveFor(association)) {
				templates.add(t);
			}
		}
		return templates;
	}
}
