=== define templates ===

The next step will be more complicated than the last one. We want to define our own template definitions, which should be used during the exporting process. There are two possibilities to define templates - *define by entries* and *define by CTM*. 

==== define by entries ====

One possibility defining templates is to create a new Template instance and add some entries representing the content of the template, as we will see in the next chapters. At first we have to create a new instance of a template with a given name.

--------------------------------------
1:	/*
2:	 * create template with the name "myTemplate"
3:	 */
4:	final String templateName = "myTemplate";
5:	Template template = new Template(templateName);
6:	/*
7:	 * add template to CTM writer
8:	 */
9:	writer.addTemplate(template);		
--------------------------------------

=====================================
Because of the clear arrangement, we split the name definition and the template definition, but of course it will be possible to do in one step. In line 4 we create a new string and set them to the value "myTemplate". In the 5th line we use the string variable to create a new template instance and add them to the CTM writer in line 9. The given name will be used in the CTM file.
=====================================

The code snippet looks very simple, because it only creates an empty template and add them to the CTM writer, but let us see the generated CTM content.

------------------------------------
1:	def myTemplate ()
2:		# empty
3:	end
------------------------------------

====================================
As you can see in the first line, the given name are used as a template identification and because of missing entries the template is empty.
====================================

The possible entries are distinguish from each other by their representing ontology and can contain variables or constants as a value.

===== define a type entry =====

Type entries representing the *type-instance-association* of the TMDM. The value of this template has to be an identifier of specific topic type or a variable.

--------------------------------------
1:	/*
2:	 * read the topic type from the topic map
3:	 */
4:	Locator locator = topicMap.createLocator("http://psi.ontopedia.net/Composer");
5:	Topic type = topicMap.getTopicBySubjectIdentifier(locator);
6:	/*
7:	 * create type entry with the specific type
8:	 */
9:	IsInstanceOfEntry entry = new IsInstanceOfEntry(type);
10:	/*
11:	 * add entry to template
12:	 */
13:	template.add(entry);
--------------------------------------

======================================
At first we will have to extract the topic type from our topic map as the essential parameter of the entry. In line 4 and 5 we use method of the TMAPI to extract a topic representing our type information. In line 9 we create a new instance of *IsInstanceOfEntry* which represent the type entry and. At last step we add the new entry to our template, as you can see in line 13.
======================================

After defining the new entry we want to check the CTM output.

--------------------------------------
1:	def myTemplate ($topic)
2:		 $topic
3:			 isa composer.
4:	end
--------------------------------------

======================================
As you can see in line 1 and 2 the template processor create a new variable *$topic* representing the topic using our template by invocation. In line 3 we can see the output of our new entry. The keyword *isa* symbolize a type-instance-association and the identifier *composer* was generated by internal processor to represent the given type *http://psi.ontopedia.net/Composer*.
======================================

===== define a super-type entry =====

Super-type entries representing the *supertype-subtype-association* of the TMDM. The value of this template has to be an identifier of specific topic supertype or a variable.

--------------------------------------
1:	/*
2:	 * read the topic type from the topic map
3:	 */
4:	Locator locator = topicMap.createLocator("http://psi.ontopedia.net/Musician");
5:	Topic supertype = topicMap.getTopicBySubjectIdentifier(locator);
6:	/*
7:	 * create type entry with the specific supertype
8:	 */
9:	AKindOfEntry entry = new AKindOfEntry(supertype);
10:	/*
11:	 * add entry to template
12:	 */
13:	template.add(entry);
--------------------------------------

======================================
At first we will have to extract the topic type from our topic map as the essential parameter of the entry. We use the the TMAPI methods to find the desired topic type representing the supertype, as you can see in line 4 and 5. In line 9 we create a new instance of *AKindOfEntry* which represent the type entry and. At last step we add the new entry to our template.
======================================

After defining the new entry we want to check the CTM output.

--------------------------------------
1:	def myTemplate ($topic)
2:		 $topic
3:			 ako musician.
4:	end
--------------------------------------

======================================
As you can see in line 1 and 2 the template processor create a new variable *$topic* representing the topic using our template by invocation. In line 3 we can see the output of our new entry. The keyword *ako* symbolize a supertype-subtype-association and the identifier *musician* was generated by internal processor to represent the given type *http://psi.ontopedia.net/Musician*.
======================================

[[name_entry]]
===== define a name entry =====

A name entry only represent a name item of a topic item. Name entries are more complex than type or supertype entries, because the number of arguments are higher, but most of them are optional and can be let out. The only non-optional parameter is the identifier information given by a variable name or a string. Name entries also can specify the type of the name, which will be represented by a topic type, as default the *default-name-type* of the TMDM will be used. The last parameter can be used to define some scoping information by a number of given themes or variables. 

---------------------------------------
1:	/*
2:	 * read the topic type of scope entry from the topic map
3:	 */
4:	Locator locator = topicMap.createLocator("http://psi.ontopedia.net/short_name");
5:	Topic shortName = topicMap.getTopicBySubjectIdentifier(locator);
6:	/*
7:	 * create new scope entry
8:	 */
9:	ScopeEntry scopeEntry = new ScopeEntry(shortName);
10:	/*
11:	 * create new name entry
12:	 */
13:	final String variable = "$name";
14:	NameEntry entry = new NameEntry(variable,scopeEntry);
15:	/*
16:	 * add entry to template
17:	 */
18:	template.add(entry);
---------------------------------------

=======================================
The code snippet show a small and simple example, how to create a name entry. In the first lines ( 4 and 5 ) the TMAPI methods are used to extract a theme represented by a topic item form the topic map. The extracted theme are used in line 9 to create a new instance of *ScopeEntry* which represents the scope information of our name entry. The real name entry are instantiated in line 14 with the value information specified by the variable *$name*. Like all entries the last necessary step is adding the entry to a template.
=======================================

After serialization let us take a look at the serialized CTM pattern.

---------------------------------------
1:	def myTemplate ($topic,  $name)
2:		 $topic
3:			 -  $name @short-name.
4:	end
---------------------------------------

=======================================
Line 3 contains the exported name entry symbolized by the hyphen at the beginning. The scope information are symbolized by *@* and a list of themes identified by there topic identity. 
=======================================

===== define an occurrence entry =====

The TMDM differs between names and occurrences as characteristic informations of a topic, because of that CTM also support two different patterns to define this, so we take a look at occurrence entries. The definition of occurrence entries are similar to name entries. The supported parameters are nearly the same, like the identifier or value parameter, the type parameter and the scope parameter, but occurrence entries additionally supporting some datatype information representing the datatype of the given value. Most of the parameters are optional two except the type and the value or identifier parameter.

---------------------------------------
1:	/*
2:	 * read the topic type of scope entry from the topic map
3:	 */
4:	Locator locator = topicMap.createLocator("http://psi.ontopedia.net/Web");
5:	Topic web = topicMap.getTopicBySubjectIdentifier(locator);
6:	/*
7:	 * create new scope entry
8:	 */
9:	ScopeEntry scopeEntry = new ScopeEntry(web);
10:	/*
11:	 * read the topic type of occurrence entry from the topic map
12:	 */
13:	locator = topicMap.createLocator("http://psi.ontopedia.net/webpage");
14:	Topic type = topicMap.getTopicBySubjectIdentifier(locator);
15:	/*
16:	 * create new occurrence entry
17:	 */
18:	final String variable = "$webpage";
19:	OccurrenceEntry entry = new OccurrenceEntry(variable,type,scopeEntry);
20:	/*
21:	 * add entry to template
22:	 */
23:	template.add(entry);
---------------------------------------

=======================================
In the code snippet we show a easy way to define our own template with exactly one occurrence entry. In line 4 and 5 we use TMAPI methods to get the topic type of our theme using in context of scoping information in line 9. In the lines 13 and 14 we use TMAPI against to get the topic type of our new occurrence. Now we can create the occurrence entry, as you can see in line 19 using the scope entry of line 9, the type of line 14 and the variable name of line 18. After all we have to add the entry to the template.   
=======================================

---------------------------------------
1:	def myTemplate ($topic,  $webpage)
2:		 $topic
3:			 webpage :  $webpage @web.
4:	end
---------------------------------------

=======================================
The 3. line containing our new occurrence entry. The pattern starts with the topic identity of the occurrence type followed by the colon. The scope information are symbolized by *@* and a list of themes identified by there topic identity.
=======================================

===== define an association entry =====

One of the core features and benefits of a topic map are associations to model relations between topic items. Templates also support the modeling of association constraints as association entries. The TMDM required that an Association is typed, because of that we have to define a topic type as the type of association item representing by the association entry. The second parameter an entry is needed are a set of role entries defining a set of parameterized role constraints. Each role constraint has to define a topic type as the type of the role and a player, which can be variable or a constant topic playing this role.

---------------------------------------
1:	/*
2:	 * create role entry for role-type composer
3:	 */
4:	Locator locatorRTA = topicMap.createLocator("http://psi.ontopedia.net/Composer");
5:	Topic typeRTA = topicMap.getTopicBySubjectIdentifier(locatorRTA);
6:	RoleEntry roleEntryA = new RoleEntry(typeRTA, "$composer");		
7:	/*
8:	 * create role entry for role-type work
9:	 */
10:	Locator locatorRTB = topicMap.createLocator("http://psi.ontopedia.net/Work");
11:	Topic typeRTB = topicMap.getTopicBySubjectIdentifier(locatorRTB);
12:	RoleEntry roleEntryB = new RoleEntry(typeRTB, "$work");
13:	/*
14:	 * create association entry by type and role entries
15:	 */
16:	Locator locator = topicMap.createLocator("http://psi.ontopedia.net/composed_by");
17:	Topic type = topicMap.getTopicBySubjectIdentifier(locator);				
18:	AssociationEntry entry = new AssociationEntry(type,roleEntryA, roleEntryB);
19:	/*
20:	 * add to template
21:	 */
22:	template.add(entry);
---------------------------------------

=======================================
The code snippet first defines two role entries between line 4 and 12. At first we have to extract the role type by using TMAPI methods. The extracted type is used to create a new instance of *RoleEntry* in line 6 or 12. After the instantiation of all role entries, we can create our new association entry. As described we have to extract the topic type as type information of our association item, so we use TMAPI in line 16ff. After all we have to add the new entry to our template.

*Note:* If you use association entries and topic entries in the same template, that could be problematic. 
=======================================

---------------------------------------
1:	def myTemplate ($composer,  $work)
2:		composed-by (
3:		 	 work : $work,
4:		 	 composer : $composer
5:		)
6:	end
---------------------------------------

=======================================
This output are generated by our template definition. In line 2 we see the association type represented by its topic identity. The round brackets symbolize the definition of an association and containing a comma separated list of role-player-constraints. Each role-player constraint are symbolized by one role entry and we can see the result of our two entries in line 3 and 4. Please note that in this case no default variable *$topic* will be created, because the template only containing association entries.
=======================================

===== define a template-invocation entry =====

The last possible entry type are template entries. Template entries realize the modeling of template-invocation as a part of templates. Of course we have to define the template, which should be called by the invocation as a parameter of the new entry.

---------------------------------------
1:	/*
2:	 * create internal template
3:	 */
4:	Template invoc = new Template("template-invoc");
5:	/*
6:	 * add entries to internal template
7:	 */
8:	NameEntry entry = new NameEntry("$name");
9:	invoc.add(entry);
10:	/*
11:	 * create template entry
12:	 */
13:	TemplateEntry templateEntry = new TemplateEntry(template, entry.getValueOrVariable());
14:	/*
15:	 * add to template
16:	 */
17:	template.add(templateEntry);
---------------------------------------

=======================================
In code snippet replacing the definition of a name entry by using a template-invocation. In line 4 we create a template instance representing the template we called by invocation. In line 8 and 9 we create a name entry in the same way we see in the example <<name_entry>>.
The new template is used to create a new template entry in line 13. The second argument of the constructor is a list of all containing variables. After all we have to add the entry to the template. 
=======================================

---------------------------------------
1:	def myTemplate ($topic,  $name)
2:		template-invoc($topic, $name)
3:	end
---------------------------------------

=======================================
Instead of containing a name entry the exported CTM pattern make use of invocations to swap out the name entry for reuse by other templates. In line 3 we see the template-invocation pattern containing the tempalte name *template-invoc* and a list of arguments represented by the template variables. As we can see the default variable *$topic* pass to the template invocation.
=======================================

==== define by CTM ====
A more comfortable way to create a template by importing a CTM file containing the CTM template definition. The template definitions look like the exported templates of the CTM writer. The drawback of this alternative is the missing possibility to control the definition process.
---------------------------------------
1:	/*
2:	 * the file containing template definitions
3:	 */
4:	final File file = new File("template.ctm");
5:	/*
6:	 * read all templates from file
7:	 */
8:	Set<Template> templates = Template.fromCTM(file);
---------------------------------------
	
=======================================
In line 4 we create a new file instance pointing to the file containing the CTM template definitions. The next step is to call the static method of the *Template* class to parse the CTM file and extract the containing template definitions. Because of the fact that each CTM file can contain more than one template, a set of templates will be returned. 
=======================================
